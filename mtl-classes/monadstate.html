<html><head><title>Cats MTL: MonadState</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Typelevel contributors" /><meta name="description" content="Monad Transformers made easy" /><meta name="og:image" content="/cats-mtl/img/poster.png" /><meta name="image" property="og:image" content="/cats-mtl/img/poster.png" /><meta name="og:title" content="Cats MTL: MonadState" /><meta name="title" property="og:title" content="Cats MTL: MonadState" /><meta name="og:site_name" content="Cats MTL" /><meta name="og:url" content="https://github.com/typelevel/cats-mtl" /><meta name="og:type" content="website" /><meta name="og:description" content="Monad Transformers made easy" /><link rel="icon" type="image/png" href="/cats-mtl/img/favicon.png" /><meta name="twitter:title" content="Cats MTL: MonadState" /><meta name="twitter:image" content="/cats-mtl/img/poster.png" /><meta name="twitter:description" content="Monad Transformers made easy" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/cats-mtl/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats-mtl/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats-mtl/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats-mtl/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats-mtl/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats-mtl/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats-mtl/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats-mtl/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats-mtl/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats-mtl/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats-mtl/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats-mtl/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats-mtl/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats-mtl/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats-mtl/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats-mtl/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats-mtl/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats-mtl/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats-mtl/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats-mtl/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats-mtl/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats-mtl/css/style.css" /><link rel="stylesheet" href="/cats-mtl/css/palette.css" /><link rel="stylesheet" href="/cats-mtl/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cats-mtl/" class="brand"><div class="brand-wrapper"><span>Cats MTL</span></div></a></li> <li><a href="/cats-mtl/mtl-classes.html" class="">MTL Type Classes</a></li> <li><a href="/cats-mtl/mtl-classes/functortell.html" class="">FunctorTell</a></li> <li><a href="/cats-mtl/mtl-classes/applicativeask.html" class="">ApplicativeAsk</a></li> <li><a href="/cats-mtl/mtl-classes/monadstate.html" class=" active ">MonadState</a></li> <li><a href="/cats-mtl/mtl-classes/monadchronicle.html" class="">MonadChronicle</a></li> <li><a href="/cats-mtl/mtl-classes/functorlisten.html" class="">FunctorListen</a></li> <li><a href="/cats-mtl/mtl-classes/applicativelocal.html" class="">ApplicativeLocal</a></li> <li><a href="/cats-mtl/mtl-classes/functorraise.html" class="">FunctorRaise</a></li> <li><a href="/cats-mtl/mtl-classes/applicativehandle.html" class="">ApplicativeHandle</a></li> </ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-mtl"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/typelevel/cats-mtl"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('Cats MTL Monad Transformers made easy');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('Cats MTL Monad Transformers made easy');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="typelevel" data-github-repo="cats-mtl"><div class="content-wrapper"><section><h2 id="monadstate">MonadState</h2>

<p><code class="highlighter-rouge">MonadState[F, S]</code> describes the capability to read and write state values of type <code class="highlighter-rouge">S</code> inside the <code class="highlighter-rouge">F[_]</code> context.
This materializes in two functions <code class="highlighter-rouge">get: F[S]</code> and <code class="highlighter-rouge">set: S =&gt; F[Unit]</code> that are needed for <code class="highlighter-rouge">MonadState</code> instances:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Simply spoken <code class="highlighter-rouge">MonadState</code> gives us the ability to thread state through computations in <code class="highlighter-rouge">F[_]</code>.
It provides access to controlled mutable state, which can be very useful, but must also be used with care.</p>

<p>There are dozens of use cases where it might make sense to use <code class="highlighter-rouge">MonadState</code>,
 one of them is to use it to maintain a cache when repeatedly accessing external services.
If we’ve already accessed a service with a given identifier, we can then access the cache instead, of course we also want the ability to invalidate the cache to receive fresh values as well.</p>

<p>Let’s say we have the following function to access a service:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="c1">// import cats._
</span>
<span class="k">import</span> <span class="nn">cats.data._</span>
<span class="c1">// import cats.data._
</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="k">import</span> <span class="nn">cats.mtl.MonadState</span>
<span class="c1">// import cats.mtl.MonadState
</span>
<span class="k">import</span> <span class="nn">cats.mtl.implicits._</span>
<span class="c1">// import cats.mtl.implicits._
</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ServiceResult</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">companies</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
<span class="c1">// defined class ServiceResult
</span>
<span class="k">def</span> <span class="n">serviceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">ServiceResult</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// a fake call to some external service, impure, so don't do this at home!
</span>  <span class="n">println</span><span class="o">(</span><span class="n">show</span><span class="s">"Called service with $id"</span><span class="o">)</span>
  <span class="nc">ServiceResult</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Raven Enterprises"</span><span class="o">)).</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>
<span class="c1">// serviceCall: [F[_]](id: String)(implicit evidence$1: cats.Monad[F])F[ServiceResult]
</span></code></pre></div></div>

<p>Now, we want a new function that looks inside of a cache for the desired value and if it’s not there, access the service and put the result inside the cache.
To do so, we’ll make use of <code class="highlighter-rouge">MonadState</code> with a simple <code class="highlighter-rouge">Map[String, ServiceResult]</code> as our cache:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Cache</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">ServiceResult</span><span class="o">]</span>
<span class="c1">// defined type alias Cache
</span>
<span class="k">def</span> <span class="n">cachedServiceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">ServiceResult</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">cache</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">serviceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">id</span><span class="o">)</span>
            <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// cachedServiceCall: [F[_]](id: String)(implicit evidence$1: cats.Monad[F], implicit F: cats.mtl.MonadState[F,Cache])F[ServiceResult]
</span></code></pre></div></div>

<p>So far, so good, we’re succesfully reading from the cache if it has the value we need, but it also doesn’t actually write anything into the cache when we call our service.
Let’s try again to write to the cache after making the service call.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">serviceCallAndWriteToCache</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">ServiceResult</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="n">serviceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">id</span><span class="o">)</span>
  <span class="n">cache</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">result</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// serviceCallAndWriteToCache: [F[_]](id: String)(implicit evidence$1: cats.Monad[F], implicit F: cats.mtl.MonadState[F,Cache])F[ServiceResult]
</span>
<span class="k">def</span> <span class="n">cachedServiceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">ServiceResult</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">cache</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">serviceCallAndWriteToCache</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">id</span><span class="o">)</span>
            <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// cachedServiceCall: [F[_]](id: String)(implicit evidence$1: cats.Monad[F], implicit F: cats.mtl.MonadState[F,Cache])F[ServiceResult]
</span></code></pre></div></div>

<p>Lastly, we want to be able to invalidate our cache. This is fairly simple, as all we need to do is to use <code class="highlighter-rouge">set</code> with an empty cache:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">invalidate</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
<span class="c1">// invalidate: [F[_]](implicit F: cats.mtl.MonadState[F,Cache])F[Unit]
</span></code></pre></div></div>

<p>Now that we have our building blocks, we can now build a program that makes a few requests then invalidates the cache and makes another request:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">ServiceResult</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">result1</span> <span class="k">&lt;-</span> <span class="n">cachedServiceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="s">"ab94d2"</span><span class="o">)</span>
  <span class="n">result2</span> <span class="k">&lt;-</span> <span class="n">cachedServiceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="s">"ab94d2"</span><span class="o">)</span> <span class="c1">// This should use the cached value
</span>  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">invalidate</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="n">freshResult</span> <span class="k">&lt;-</span> <span class="n">cachedServiceCall</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="s">"ab94d2"</span><span class="o">)</span> <span class="c1">// This should access the service again
</span><span class="o">}</span> <span class="k">yield</span> <span class="n">freshResult</span>
<span class="c1">// program: [F[_]](implicit evidence$1: cats.Monad[F], implicit F: cats.mtl.MonadState[F,Cache])F[ServiceResult]
</span></code></pre></div></div>

<p>And we’re done, now, to be able to run this, we need to materialize our <code class="highlighter-rouge">program</code> into an actual value.
As the name suggests, <code class="highlighter-rouge">State</code> and <code class="highlighter-rouge">StateT</code> both allow us to use <code class="highlighter-rouge">MonadState</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">initialCache</span><span class="k">:</span> <span class="kt">Cache</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="c1">// initialCache: Cache = Map()
</span>
<span class="k">val</span> <span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">cache</span><span class="o">)</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Cache</span>, <span class="kt">?</span><span class="o">]].</span><span class="n">run</span><span class="o">(</span><span class="n">initialCache</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// Called service with ab94d2
// Called service with ab94d2
// result: scala.collection.immutable.Map[String,ServiceResult] = Map(ab94d2 -&gt; ServiceResult(0,List(Raven Enterprises)))
// cache: ServiceResult = ServiceResult(0,List(Raven Enterprises))
</span></code></pre></div></div>

<p>As per usual, Cats-mtl provides <code class="highlighter-rouge">MonadState</code> instances for all monad transformer stacks where <code class="highlighter-rouge">StateT</code> appears.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cats-mtl/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats-mtl'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/cats-mtl/js/main.js"></script></body></html>